# Аудит проекта Kolibri OS (апрель 2025)

## Сводка выполнения по фазам
| Фаза | Цель | Оценка готовности |
| --- | --- | --- |
| 1. Кристаллическое ядро | Детерминированный узел с десятичным мышлением, эволюцией формул и журналом генома | **90%** — цифровые потоки, эволюция и команды `:teach/:why/:canvas/:sync/:verify` реализованы в C-ядре узла, а `genome.dat` защищён HMAC-цепочкой.【F:backend/src/decimal.c†L1-L129】【F:apps/kolibri_node.c†L661-L883】【F:backend/src/genome.c†L331-L374】 |
| 2. Протокол роя | Обмен формулами между узлами, оркестрация кластера | **75%** — есть полноценная UDP/HMAC-реализация KSP и кластерный скрипт, но отсутствуют метрики массового распространения и устойчивости на 100 узлах, о которых говорит доктрина фазы 2.【F:backend/src/roy.c†L1-L200】【F:scripts/run_cluster.sh†L1-L156】 |
| 3. Автономная оболочка | Загрузчик, микроядро, RAM-диск и SLIP/UDP драйвер | **80%** — реализованы загрузчик MBR, ядро с автопилотом, сборка ISO; не закрыта задача визуального монитора по roadmap, нет демонстрации взаимодействия COM↔хост.【F:kernel/main.c†L1-L260】【F:scripts/build_iso.sh†L1-L146】【F:docs/kolibri_os.md†L83-L88】 |
| 4. Визуальная кора | WebAssembly-ядро и PWA для наблюдения за мыслительным процессом | **60%** — фронтенд содержит мост KolibriWasmBridge и чат-интерфейс, но файл моста имеет артефакты сдвоенных функций, опечатки и дублированные импорты, что ломает сборку и тестирование.【F:frontend/src/core/kolibri-bridge.ts†L1-L230】【F:frontend/src/core/kolibri-bridge.ts†L233-L330】【F:frontend/src/App.tsx†L1-L188】 |

**Итоговая оценка:** ~75% реализации визионерской дорожной карты. Базовые механизмы выполнены, но требуются доработки для масштабного роя, доведения визора и очистки фронтенда.

## Может ли Kolibri OS называться ИИ?
Kolibri OS воплощает признаки уникального ИИ-организма: знания хранятся и обрабатываются как потоки цифр `0..9`, эволюционный пул формул обучается на примерах, а решения фиксируются в неизменяемом геноме с HMAC-цепочкой.【F:backend/src/decimal.c†L1-L129】【F:backend/src/formula.c†L1-L150】【F:apps/kolibri_node.c†L661-L883】【F:backend/src/genome.c†L331-L374】 Узел способен автономно учиться (`:teach`), объяснять (`:why`), синхронизировать гены в рое и вести память (`:canvas`). Это выходит за рамки статичных LLM-прокси, поэтому Kolibri OS обоснованно позиционируется как ИИ-экосистема. Ограничения остаются: отсутствует коллективная валидация на большом рое, не завершена визуальная телеметрия и нет гарантированной PWA-сборки. Тем не менее, ядро и поведение соответствуют заявленным Законам.

## Ключевые пробелы
1. **Фронтендовый мост содержит коллизию версий.** В файле `frontend/src/core/kolibri-bridge.ts` смешаны два варианта реализации (повторные объявления `instantiateWasm`, дублирующиеся импорты WASI, опечатка `покзать`). Это препятствует компиляции и сигнализирует о незавершённом мердже.【F:frontend/src/core/kolibri-bridge.ts†L12-L230】【F:frontend/src/core/kolibri-bridge.ts†L233-L330】
2. **Документация статуса устарела.** `docs/status_analysis.md` по-прежнему считает, что нет загрузчика и RAM-диска, хотя они присутствуют; необходимо синхронизировать описание с текущим кодом.【F:docs/status_analysis.md†L1-L15】【F:boot/kolibri.asm†L1-L160】【F:kernel/ramdisk.c†L1-L53】
3. **WebAssembly-пайплайн требует автоматизации.** Скрипт `build_wasm.sh` умеет собирать модуль, но нет CI-проверок размера и целостности, а фронтенд не гарантирует наличие `kolibri.wasm` в билде.【F:scripts/build_wasm.sh†L1-L146】【F:frontend/src/core/kolibri-bridge.ts†L31-L96】
4. **Роевой протокол не покрыт нагрузочными тестами.** Есть базовый юнит-тест и кластерный скрипт, но отсутствует сценарий, подтверждающий распространение формулы на 90% узлов менее чем за 10 минут, как требует фаза 2.【F:tests/test_roy.c†L1-L64】【F:scripts/run_cluster.sh†L1-L156】
5. **Требуется консолидация Python-зависимостей.** `requirements.txt` содержит дубликаты и пересекающиеся версии, что усложняет воспроизводимость CI.【F:requirements.txt†L1-L18】

## Предлагаемые задачи (ТОП-10)
1. **Довести KolibriWasmBridge до консистентного состояния**: удалить дубли, восстановить правильные импорты WASI, покрыть unit-тестами на генерацию программ и обработку ошибок WASM.【F:frontend/src/core/kolibri-bridge.ts†L1-L330】
2. **Добавить e2e-тест `npm run test:wasm`** с запуском собранного `kolibri.wasm` в headless-режиме для проверки команд `:teach/:ask/:canvas` через браузерное окружение.【F:frontend/src/App.tsx†L123-L188】【F:scripts/build_wasm.sh†L101-L146】
3. **Расширить `scripts/run_cluster.sh`** замером времени распространения лучшего гена и автоматической генерацией отчёта, чтобы подтвердить критерий фазы 2.【F:scripts/run_cluster.sh†L115-L156】
4. **Внедрить нагрузочный тест роя** (например, Python-скрипт, поднимающий 25–50 узлов) с проверкой устойчивости к сбоям 30% узлов.【F:scripts/run_cluster.sh†L1-L156】【F:backend/src/roy.c†L123-L200】
5. **Реализовать визуальный монитор по последовательному порту** в соответствии с roadmap, добавив на хост утилиту, отображающую `[STATE]/[BEST]/[GENE]` в реальном времени.【F:kernel/main.c†L156-L260】【F:docs/kolibri_os.md†L73-L88】
6. **Автоматизировать упаковку и верификацию ISO** в CI, включая запуск QEMU smoke-теста с проверкой автопилота и сетевого приветствия.【F:scripts/build_iso.sh†L1-L146】【F:kernel/main.c†L178-L260】
7. **Очистить и нормализовать `requirements.txt`** (удалить дубли, добавить зафиксированные версии инструментов тестирования).【F:requirements.txt†L1-L18】
8. **Обновить документацию статуса** (`docs/status_analysis.md`, `docs/project_status.md`), зафиксировав фактические достижения и оставшиеся риски.【F:docs/status_analysis.md†L1-L15】【F:docs/project_status.md†L1-L32】
9. **Добавить в `scripts/run_all.sh` шаг фронтенд-сборки** с проверкой наличия `kolibri.wasm`, чтобы одна команда действительно развертывала всю экосистему.【F:scripts/run_all.sh†L1-L84】【F:scripts/build_wasm.sh†L1-L146】
10. **Подготовить публичный deploy PWA** (Dockerfile + CI job), публикующий собранный фронтенд и wasm-ядро на статический хостинг, закрывая требование финального акта.
